package com.mygame.f1;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.GlyphLayout;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.graphics.glutils.FrameBuffer;
import com.badlogic.gdx.maps.MapGroupLayer;
import com.badlogic.gdx.maps.MapLayer;
import com.badlogic.gdx.maps.MapObject;
import com.badlogic.gdx.maps.MapObjects;
import com.badlogic.gdx.maps.MapProperties;
import com.badlogic.gdx.maps.objects.PolygonMapObject;
import com.badlogic.gdx.maps.objects.RectangleMapObject;
import com.badlogic.gdx.maps.tiled.TiledMap;
import com.badlogic.gdx.maps.tiled.TiledMapTile;
import com.badlogic.gdx.maps.tiled.TiledMapTileLayer;
import com.badlogic.gdx.maps.tiled.TmxMapLoader;
import com.badlogic.gdx.maps.tiled.renderers.OrthogonalTiledMapRenderer;
import com.badlogic.gdx.math.EarClippingTriangulator;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.*;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.ui.Label;
import com.badlogic.gdx.scenes.scene2d.ui.Skin;
import com.badlogic.gdx.scenes.scene2d.ui.Table;
import com.badlogic.gdx.scenes.scene2d.ui.TextButton;
import com.badlogic.gdx.utils.ShortArray;
import com.badlogic.gdx.utils.viewport.FitViewport;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import com.badlogic.gdx.utils.viewport.Viewport;
import com.mygame.f1.screens.MainMenuScreen;
import com.mygame.f1.ui.SkinFactory;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class GameScreen implements Screen {

    private enum GameState { PRE_START, NORMAL, PIT_ENTERING, PIT_MINIGAME, PIT_EXITING }

    private final Main gameRef;

    private final Vector2 v2_tmp1 = new Vector2();
    private final Vector2 v2_tmp2 = new Vector2();

    private World world;
    private Box2DDebugRenderer box2DDebugRenderer;
    private ShapeRenderer shapeRenderer; // 디버그용
    private Body playerCar;
    private float accumulator = 0;
    private static final float TIME_STEP = 1 / 60f;

    private OrthographicCamera camera;
    private Viewport viewport;
    private float cameraAngle = 0f;
    private float positionSmoothness = 5.0f;
    private float cameraRotationSmoothness = 3.0f;
    private float cameraOffsetFromCar = 0.8f;

    private TiledMap map;
    private OrthogonalTiledMapRenderer mapRenderer;
    private SpriteBatch batch;
    private Texture carTexture;
    private Texture backgroundTexture;
    private Texture lapBestBgTexture;
    private Texture lapLastBgTexture;
    private Texture minimapFrameTexture;
    private Texture minimapCarTexture;
    private TextureRegion minimapRegion;
    private Texture durabilityLabelTexture;
    private Texture durabilityBgTexture;
    private Texture durabilityFgTexture;
    private Texture raceStatusTexture;
    private Texture speedHudTexture;
    private Texture tireLabelTexture;
    private Texture tireBgTexture;
    private Texture tireFgTexture;
    private Texture tireCompoundTexture;
    private Texture tireCompoundSoftTexture;
    private Texture tireCompoundMediumTexture;
    private Texture tireCompoundHardTexture;
    private Texture pitPanelTexture;
    private Texture pitBarTexture;
    private Texture pitPointerTexture;
    private Texture pitTyreSelectTexture;
    private Texture light3Texture;
    private Texture light2Texture;
    private Texture light1Texture;
    private Texture lightGoTexture;

    private boolean paused = false;
    private Stage pauseStage;
    private Skin pauseSkin;
    private BitmapFont debugFont;
    private BitmapFont raceStatusFont;
    private BitmapFont speedFont;
    private OrthographicCamera hudCamera;
    private OrthographicCamera minimapCamera;
    private FrameBuffer minimapFbo;
    private boolean debugRenderEnabled = false;

    // 차량 속도, 조작감 관련 변수
    private float maxForwardSpeed = 5.0f;   // was 3.5f
    private float maxReverseSpeed = 2.2f;   // was 1.5f
    private float forwardAcceleration = 4.5f; // was 2.5f
    private float reverseAcceleration = 2.5f; // was 1.5f
    private float turningPower = 12f;      // was 10f
    private float grip = 16.0f; // 조금 낮춰 마찰을 줄여 가속 손실 완화
    private float minSpeedForTurn = 0.8f;
    private float accelerationSmoothness = 7f;
    private float currentAcceleration = 0f;
    private float defaultLinearDamping = 1.5f;
    private float brakingLinearDamping = 4.0f;
    private float collisionDamping = 3.5f;

    private boolean isColliding = false;
    private boolean wasColliding = false;
    private float collisionTimer = 0f;
    private float collisionDuration = 0.2f;

    private int grassContacts = 0;
    private float grassDamping = 12.0f; 

    private static class Checkpoint {
        int index;
        Rectangle bounds;
        Checkpoint(int index, Rectangle bounds) {
            this.index = index;
            this.bounds = bounds;
        }
    }
    private List<Checkpoint> checkpoints = new ArrayList<>();
    private Rectangle startLineBounds;
    private int totalCheckpoints = 0;
    private int lastCheckpointIndex = 0;
    private int currentLap = 0;
    private int totalLaps = 3;
    private Set<Integer> checkpointsInside = new HashSet<>();
    private boolean insideStartLine = false;
    private float initialAngle = 0f;
    private float lapTimeSeconds = 0f;
    private float bestLapTime = -1f;
    private float lastLapTime = -1f;
    private float mapWorldWidth = 0f;
    private float mapWorldHeight = 0f;
    private float minimapFrameSize = 260f;
    private float minimapInset = 8f;
    private float minimapPadding = 40f;
    private float durabilityPercent = 100f;
    private float durabilityDecayPerSecond = 0.8f; // ?? ? ?? ???(%) / sec
    private int playerIndex = 1;
    private int playerRank = 1;
    private float tireDurabilityPercent = 100f;
    private String tireCompound = "medium"; // soft / medium / hard
    private float tireWearThreshold = 0.5f;
    private float softWearRate = 100f / 50f;  // 타이어 내구도 감소 속도 (% / sec)
    private float mediumWearRate = 100f / 70f;
    private float hardWearRate = 100f / 90f;
    private GameState gameState = GameState.NORMAL;
    private Rectangle pitEntryRect;
    private Rectangle pitServiceRect;
    private Rectangle pitExitRect;
    private Vector2 pitServicePos = new Vector2();
    private Vector2 pitExitPos = new Vector2();
    private float pitExitAngleDeg = 0f;
    private float pitServiceAngleDeg = 0f;
    private String pitSelectedCompound = "medium";
    private float pitPointerT = 0.5f;
    private float pitPointerDir = 1f;
    private float pitPointerSpeed = 1.5f;
    private String lastPitResult = "";
    private float pitServiceTimeTotal = 0f;
    private float pitServiceTimeRemaining = 0f;
    private boolean pitMiniGameLocked = false;
    private float startCountdown = 3.0f;
    private float startDelay = 1.5f; // map load 후 대기 시간
    private float startDelayRemaining = 0f;
    private float goDisplayTime = 0.3f;
    private float goTimer = 0f;
    private float offDisplayTime = 0.3f;
    private float offTimer = 0f;
    private boolean goJustStarted = false;
    private boolean startLightsDone = false;
    public static final float PPM = 100;
    private static final boolean USE_TILED_MAP = true;

    public GameScreen() { this(null); }

    public GameScreen(Main game) { this.gameRef = game; }

    @Override
    public void show() {
        // 1. 카메라 초기화
        camera = new OrthographicCamera();
        viewport = new FitViewport(1600 / PPM, 900 / PPM, camera);
        camera.zoom = 0.5f;

        // 2. 에셋 초기화
        batch = new SpriteBatch();
        carTexture = Main.assetManager.get("pitstop_car_3.png", Texture.class);
        backgroundTexture = Main.assetManager.get("Track_t2.png", Texture.class);
        lapBestBgTexture = loadTextureSafe("ui/laptime/lap_time_bg_best.png");
        lapLastBgTexture = loadTextureSafe("ui/laptime/lap_time_bg_last.png");
        minimapFrameTexture = loadTextureSafe("hud/minimap_frame_bg.png");
        durabilityLabelTexture = loadTextureSafe("ui/durability/vehicle_durability_label.png");
        durabilityBgTexture = loadTextureSafe("ui/durability/vehicle_durability_bg.png");
        durabilityFgTexture = loadTextureSafe("ui/durability/vehicle_durability_fg.png");
        raceStatusTexture = loadTextureSafe("hud/race_status_bg.png");
        speedHudTexture = loadTextureSafe("ui/speed/speed_hud_bg.png");
        tireLabelTexture = loadTextureSafe("ui/tire/tire_durability_label.png");
        tireBgTexture = loadTextureSafe("ui/tire/tire_durability_bg.png");
        tireFgTexture = loadTextureSafe("ui/tire/tire_durability_fg.png");
        tireCompoundSoftTexture = loadTextureSafe("ui/tire/tire_durability_compound_soft.png");
        tireCompoundMediumTexture = loadTextureSafe("ui/tire/tire_durability_compound_medium.png");
        tireCompoundHardTexture = loadTextureSafe("ui/tire/tire_durability_compound_hard.png");
        // 기본 compound: medium
        tireCompoundTexture = tireCompoundMediumTexture;
        if (tireCompoundTexture == null) {
            if (tireCompoundSoftTexture != null) tireCompoundTexture = tireCompoundSoftTexture;
            else if (tireCompoundHardTexture != null) tireCompoundTexture = tireCompoundHardTexture;
        }
        pitPanelTexture = loadTextureSafe("ui/pit/pit_minigame_panel.png");
        pitBarTexture = loadTextureSafe("ui/pit/pit_timing_bar_bg.png");
        pitPointerTexture = loadTextureSafe("ui/pit/pit_pointer.png");
        pitTyreSelectTexture = loadTextureSafe("ui/pit/tyre_select_panel.png");
        light3Texture = loadTextureSafe("ui/startLight/light_3.png");
        light2Texture = loadTextureSafe("ui/startLight/light_2.png");
        light1Texture = loadTextureSafe("ui/startLight/light_1.png");
        lightGoTexture = loadTextureSafe("ui/startLight/light_go.png");
        Pixmap pm = new Pixmap(8, 8, Pixmap.Format.RGBA8888);
        pm.setColor(1f, 0.3f, 0.3f, 1f);
        pm.fillCircle(4, 4, 4);
        minimapCarTexture = new Texture(pm);
        pm.dispose();

        // 3. 물리 월드 초기화
        world = new World(new Vector2(0, 0), true);
        box2DDebugRenderer = new Box2DDebugRenderer();
        shapeRenderer = new ShapeRenderer();

        // 4. 충돌 리스너 설정
        world.setContactListener(new ContactListener() {
            @Override
            public void beginContact(Contact contact) {
                Fixture fa = contact.getFixtureA();
                Fixture fb = contact.getFixtureB();

                if (isPlayer(fa) || isPlayer(fb)) {
                    Fixture other = isPlayer(fa) ? fb : fa;
                    String userData = (other.getUserData() != null) ? other.getUserData().toString() : "";

                    // (1) 잔디 진입
                    if ("grass".equals(userData)) {
                        grassContacts++;
                    }
                    // (2) 벽 충돌 (센서가 아닐 때만)
                    else if (!other.isSensor()) {
                        durabilityPercent = Math.max(0f, durabilityPercent - 3f);
                        collisionTimer = collisionDuration;
                        Vector2 velocity = playerCar.getLinearVelocity();
                        playerCar.setLinearVelocity(velocity.scl(0.4f));
                        playerCar.setAngularVelocity(playerCar.getAngularVelocity() * 0.3f);
                    }
                }
            }

            @Override
            public void endContact(Contact contact) {
                Fixture fa = contact.getFixtureA();
                Fixture fb = contact.getFixtureB();

                if (isPlayer(fa) || isPlayer(fb)) {
                    Fixture other = isPlayer(fa) ? fb : fa;
                    String userData = (other.getUserData() != null) ? other.getUserData().toString() : "";

                    // 잔디 탈출
                    if ("grass".equals(userData)) {
                        grassContacts--;
                        if (grassContacts < 0) grassContacts = 0;
                    }
                }
            }
            private boolean isPlayer(Fixture f) { return f.getBody() == playerCar; }
            @Override public void preSolve(Contact contact, Manifold oldManifold) {}
            @Override public void postSolve(Contact contact, ContactImpulse impulse) {}
        });

        // 5. Tiled map load and world objects
        if (USE_TILED_MAP) {
            map = new TmxMapLoader().load("f1_racing_map.tmx");
            mapRenderer = new OrthogonalTiledMapRenderer(map, 1 / PPM);
            
            // [A] 'collision' object layer -> walls
            MapLayer collisionLayer = getLayer(map, "collision");
            if (collisionLayer == null) collisionLayer = getLayer(map, "Collision");
            if (collisionLayer != null) {
                int wallsCreated = 0;
                for (MapObject object : collisionLayer.getObjects()) {
                    if (object instanceof RectangleMapObject) {
                        Rectangle rect = ((RectangleMapObject) object).getRectangle();
                        float wallX = rect.x / PPM;
                        float wallY = rect.y / PPM;
                        createWall(wallX, wallY, rect.width / PPM, rect.height / PPM);
                        wallsCreated++;
                    } else if (object instanceof PolygonMapObject) {
                        createPolygonWall((PolygonMapObject) object);
                        wallsCreated++;
                    }
                }
                Gdx.app.log("Collision", "Created walls from 'collision' layer: " + wallsCreated);
            } else {
                Gdx.app.log("Collision", "Layer 'collision' not found.");
            }

            // [B] 'Grass' polygon sensor load
            MapLayer grassLayer = getLayer(map, "Grass");
            if (grassLayer != null) {
                for (MapObject object : grassLayer.getObjects()) {
                    if (object instanceof PolygonMapObject) {
                        createGrassZone((PolygonMapObject) object);
                    }
                }
                Gdx.app.log("Collision", "Grass layer loaded.");
            }

            // [C] checkpoints & start line load
            loadCheckpointsFromMap();
            loadStartLineFromMap();
            loadPitAreasFromMap();
            buildMinimap();
        }

        // 6. Player & UI init
        createPlayerCar();
        
        initialAngle = playerCar.getAngle();

        pauseSkin = SkinFactory.createDefaultSkin();
        pauseStage = new Stage(new ScreenViewport());
        debugFont = new BitmapFont();
        try {
            FreeTypeFontGenerator gen = new FreeTypeFontGenerator(Gdx.files.internal("fonts/NotoSansKR-Bold.ttf"));
            FreeTypeFontGenerator.FreeTypeFontParameter p = new FreeTypeFontGenerator.FreeTypeFontParameter();
            p.size = 24;
            p.color = Color.BLACK;
            raceStatusFont = gen.generateFont(p);

            FreeTypeFontGenerator.FreeTypeFontParameter p2 = new FreeTypeFontGenerator.FreeTypeFontParameter();
            p2.size = 42;
            p2.color = Color.WHITE;
            speedFont = gen.generateFont(p2);
            gen.dispose();
        } catch (Exception e) {
            raceStatusFont = debugFont;
            speedFont = debugFont;
        }
        hudCamera = new OrthographicCamera();
        hudCamera.setToOrtho(false, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
        gameState = GameState.PRE_START;
        startCountdown = 3.0f;
        startDelayRemaining = startDelay;
        goTimer = 0f;
        offTimer = 0f;
        goJustStarted = false;
        startLightsDone = false;
    }

    // 레이어 찾기 헬퍼 (그룹 지원)
    private MapLayer getLayer(TiledMap map, String layerName) {
        MapLayer layer = map.getLayers().get(layerName);
        if (layer == null) {
            MapLayer groupLayer = map.getLayers().get("object");
            if (groupLayer instanceof MapGroupLayer) {
                layer = ((MapGroupLayer) groupLayer).getLayers().get(layerName);
            }
        }
        return layer;
    }

    
    // --- Checkpoint loading ---
    private void loadCheckpointsFromMap() {
        checkpoints.clear();
        totalCheckpoints = 0;
        checkpointsInside.clear();
        lastCheckpointIndex = 0;
        currentLap = 0;

        MapLayer cpLayer = getLayer(map, "checkpoints");
        if (cpLayer == null) {
            Gdx.app.log("Checkpoint", "Layer 'checkpoints' not found.");
            return;
        }

        for (MapObject obj : cpLayer.getObjects()) {
            if (!(obj instanceof RectangleMapObject)) continue;
            MapProperties props = obj.getProperties();
            if (!props.containsKey("cpIndex")) continue;

            int index;
            try {
                Object cpValue = props.get("cpIndex");
                if (cpValue instanceof Number) index = ((Number) cpValue).intValue();
                else index = Integer.parseInt(cpValue.toString());
            } catch (Exception e) {
                Gdx.app.log("Checkpoint", "cpIndex is not numeric: " + e.getMessage());
                continue;
            }

            Rectangle rectPx = ((RectangleMapObject) obj).getRectangle();
            Rectangle rectWorld = new Rectangle(rectPx.x / PPM, rectPx.y / PPM, rectPx.width / PPM, rectPx.height / PPM);

            checkpoints.add(new Checkpoint(index, rectWorld));
            totalCheckpoints = Math.max(totalCheckpoints, index);
        }
        checkpoints.sort((a, b) -> Integer.compare(a.index, b.index));
        Gdx.app.log("Checkpoint", "Loaded " + checkpoints.size() + ", last index=" + totalCheckpoints);
    }

    // --- Start line loading ---
    private void loadStartLineFromMap() {
        startLineBounds = null;
        MapLayer startLayer = getLayer(map, "startgrid");
        if (startLayer == null) {
            Gdx.app.log("Checkpoint", "Layer 'startgrid' not found.");
            return;
        }
        for (MapObject obj : startLayer.getObjects()) {
            if (!(obj instanceof RectangleMapObject)) continue;
            MapProperties props = obj.getProperties();
            Object typeObj = props.get("type");
            if (typeObj != null && "start_line".equals(typeObj.toString())) {
                Rectangle rectPx = ((RectangleMapObject) obj).getRectangle();
                startLineBounds = new Rectangle(rectPx.x / PPM, rectPx.y / PPM, rectPx.width / PPM, rectPx.height / PPM);
                Gdx.app.log("Checkpoint", "Start line loaded.");
                break;
            }
        }
    }

    private void loadPitAreasFromMap() {
        pitEntryRect = null;
        pitServiceRect = null;
        pitExitRect = null;
        MapLayer pitLayer = getLayer(map, "pit");
        if (pitLayer == null) return;
        for (MapObject obj : pitLayer.getObjects()) {
            if (!(obj instanceof RectangleMapObject)) continue;
            Rectangle rectPx = ((RectangleMapObject) obj).getRectangle();
            Rectangle rectWorld = new Rectangle(rectPx.x / PPM, rectPx.y / PPM, rectPx.width / PPM, rectPx.height / PPM);
            MapProperties props = obj.getProperties();
            String type = String.valueOf(props.get("type"));
            if ("PIT_ENTRY".equals(type)) {
                pitEntryRect = rectWorld;
            } else if ("PIT_SERVICE".equals(type)) {
                pitServiceRect = rectWorld;
                pitServicePos.set(rectWorld.x + rectWorld.width / 2f, rectWorld.y + rectWorld.height / 2f);
                Object ang = props.get("serviceAngle");
                if (ang instanceof Number) pitServiceAngleDeg = ((Number) ang).floatValue();
            } else if ("PIT_EXIT".equals(type)) {
                pitExitRect = rectWorld;
                pitExitPos.set(rectWorld.x + rectWorld.width / 2f, rectWorld.y + rectWorld.height / 2f);
                Object ang = props.get("exitAngle");
                if (ang instanceof Number) pitExitAngleDeg = ((Number) ang).floatValue();
            }
        }
    }

    private Texture loadTextureSafe(String path) {
        try {
            if (Gdx.files.internal(path).exists()) {
                return new Texture(Gdx.files.internal(path));
            } else {
                Gdx.app.log("Asset", "Missing texture: " + path);
                return null;
            }
        } catch (Exception e) {
            Gdx.app.log("Asset", "Failed to load texture: " + path + " error=" + e.getMessage());
            return null;
        }
    }


    private void updateLapAndCheckpoints() {
        if (checkpoints.isEmpty()) return;
        Vector2 carPos = playerCar.getPosition();

        for (Checkpoint cp : checkpoints) {
            boolean contains = cp.bounds.contains(carPos.x, carPos.y);
            boolean alreadyInside = checkpointsInside.contains(cp.index);

            if (contains && !alreadyInside) {
                checkpointsInside.add(cp.index);
                if (cp.index == lastCheckpointIndex + 1) {
                    lastCheckpointIndex = cp.index;
                    System.out.println("CheckPoint " + cp.index + " 통과!");
                }
            } else if (!contains && alreadyInside) {
                checkpointsInside.remove(cp.index);
            }
        }

        if (startLineBounds != null) {
            boolean inStart = startLineBounds.contains(carPos.x, carPos.y);
            if (inStart && !insideStartLine) {
                insideStartLine = true;
                if (totalCheckpoints > 0 && lastCheckpointIndex == totalCheckpoints) {
                    onLapCompleted();
                    currentLap++;
                    lastCheckpointIndex = 0;
                    System.out.println("Lap " + currentLap + " finished");
                }
            } else if (!inStart && insideStartLine) {
                insideStartLine = false;
            }
        }

    }

    private void onLapCompleted() {
        lastLapTime = lapTimeSeconds;
        if (bestLapTime < 0 || (lastLapTime > 0 && lastLapTime < bestLapTime)) {
            bestLapTime = lastLapTime;
        }
        lapTimeSeconds = 0f;
    }

    private String formatLapTime(float seconds) {
        if (seconds < 0) return "--:--.---";
        int totalMillis = Math.round(seconds * 1000f);
        int minutes = totalMillis / 60000;
        float remaining = seconds - minutes * 60f;
        return String.format("%d:%06.3f", minutes, remaining);
    }

    private void buildMinimap() {
        if (!USE_TILED_MAP || map == null || mapRenderer == null) return;

        Object wObj = map.getProperties().get("width");
        Object hObj = map.getProperties().get("height");
        Object twObj = map.getProperties().get("tilewidth");
        Object thObj = map.getProperties().get("tileheight");
        if (wObj instanceof Integer && hObj instanceof Integer && twObj instanceof Integer && thObj instanceof Integer) {
            mapWorldWidth = ((Integer) wObj) * ((Integer) twObj) / PPM;
            mapWorldHeight = ((Integer) hObj) * ((Integer) thObj) / PPM;
        } else {
            mapWorldWidth = 40f;
            mapWorldHeight = 40f;
        }

        minimapCamera = new OrthographicCamera(mapWorldWidth, mapWorldHeight);
        minimapCamera.position.set(mapWorldWidth / 2f, mapWorldHeight / 2f, 0);
        minimapCamera.update();

        minimapFbo = new FrameBuffer(Pixmap.Format.RGBA8888, 256, 256, false);
        minimapFbo.begin();
        Gdx.gl.glClearColor(0, 0, 0, 0);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
        mapRenderer.setView(minimapCamera);
        mapRenderer.render();
        minimapFbo.end();

        minimapRegion = new TextureRegion(minimapFbo.getColorBufferTexture());
        minimapRegion.flip(false, true);
    }

    private void setExpandedMapView(OrthographicCamera cam) {
        if (!USE_TILED_MAP || mapRenderer == null || viewport == null || cam == null) return;

        float viewW = viewport.getWorldWidth() * 3f;
        float viewH = viewport.getWorldHeight() * 3f;
        float viewX = cam.position.x - viewW * 0.5f;
        float viewY = cam.position.y - viewH * 0.5f;

        mapRenderer.setView(cam.combined, viewX, viewY, viewW, viewH);
    }

    private void createWall(float x, float y, float width, float height) {
        BodyDef bodyDef = new BodyDef();
        bodyDef.type = BodyDef.BodyType.StaticBody;
        bodyDef.position.set(x + width / 2, y + height / 2); // 중심점 보정 (+, +)
        Body body = world.createBody(bodyDef);

        PolygonShape shape = new PolygonShape();
        shape.setAsBox(width / 2, height / 2);
        
        FixtureDef fixtureDef = new FixtureDef();
        fixtureDef.shape = shape;
        fixtureDef.friction = 0.3f;
        fixtureDef.restitution = 0.02f;
        
        Fixture fixture = body.createFixture(fixtureDef);
        fixture.setUserData("wall");
        shape.dispose();
    }

    private void createPolygonWall(PolygonMapObject polygonObject) {
        float[] vertices = polygonObject.getPolygon().getTransformedVertices();
        if (vertices.length < 6) return;

        float[] worldVertices = new float[vertices.length];
        for (int i = 0; i < vertices.length; i++) worldVertices[i] = vertices[i] / PPM;

        EarClippingTriangulator triangulator = new EarClippingTriangulator();
        ShortArray triangleIndices = triangulator.computeTriangles(worldVertices);

        BodyDef bodyDef = new BodyDef();
        bodyDef.type = BodyDef.BodyType.StaticBody;
        bodyDef.position.set(0, 0);
        Body body = world.createBody(bodyDef);

        for (int i = 0; i < triangleIndices.size; i += 3) {
            Vector2 v1 = new Vector2(worldVertices[triangleIndices.get(i) * 2], worldVertices[triangleIndices.get(i) * 2 + 1]);
            Vector2 v2 = new Vector2(worldVertices[triangleIndices.get(i + 1) * 2], worldVertices[triangleIndices.get(i + 1) * 2 + 1]);
            Vector2 v3 = new Vector2(worldVertices[triangleIndices.get(i + 2) * 2], worldVertices[triangleIndices.get(i + 2) * 2 + 1]);

            float area = Math.abs(v1.x * (v2.y - v3.y) + v2.x * (v3.y - v1.y) + v3.x * (v1.y - v2.y)) / 2.0f;
            if (area < 0.00001f) continue;

            PolygonShape shape = new PolygonShape();
            shape.set(new float[]{v1.x, v1.y, v2.x, v2.y, v3.x, v3.y});

            FixtureDef fixtureDef = new FixtureDef();
            fixtureDef.shape = shape;
            fixtureDef.friction = 0.3f;
            fixtureDef.restitution = 0.02f;

            Fixture fixture = body.createFixture(fixtureDef);
            fixture.setUserData("wall");
            shape.dispose();
        }
    }

    private void createGrassZone(PolygonMapObject polygonObject) {
        float[] vertices = polygonObject.getPolygon().getTransformedVertices();
        if (vertices.length < 6) return;

        float[] worldVertices = new float[vertices.length];
        for (int i = 0; i < vertices.length; i++) worldVertices[i] = vertices[i] / PPM;

        EarClippingTriangulator triangulator = new EarClippingTriangulator();
        ShortArray triangleIndices = triangulator.computeTriangles(worldVertices);

        BodyDef bodyDef = new BodyDef();
        bodyDef.type = BodyDef.BodyType.StaticBody;
        bodyDef.position.set(0, 0);
        Body body = world.createBody(bodyDef);

        for (int i = 0; i < triangleIndices.size; i += 3) {
            Vector2 v1 = new Vector2(worldVertices[triangleIndices.get(i) * 2], worldVertices[triangleIndices.get(i) * 2 + 1]);
            Vector2 v2 = new Vector2(worldVertices[triangleIndices.get(i + 1) * 2], worldVertices[triangleIndices.get(i + 1) * 2 + 1]);
            Vector2 v3 = new Vector2(worldVertices[triangleIndices.get(i + 2) * 2], worldVertices[triangleIndices.get(i + 2) * 2 + 1]);

            float area = Math.abs(v1.x * (v2.y - v3.y) + v2.x * (v3.y - v1.y) + v3.x * (v1.y - v2.y)) / 2.0f;
            if (area < 0.00001f) continue;

            PolygonShape shape = new PolygonShape();
            shape.set(new float[]{v1.x, v1.y, v2.x, v2.y, v3.x, v3.y});
            
            FixtureDef fixtureDef = new FixtureDef();
            fixtureDef.shape = shape;
            fixtureDef.isSensor = true;
            
            Fixture fixture = body.createFixture(fixtureDef);
            fixture.setUserData("grass");
            shape.dispose();
        }
    }

    private void createPlayerCar() {
        BodyDef bodyDef = new BodyDef();
        bodyDef.type = BodyDef.BodyType.DynamicBody;

       
        float x_spawn = /*(88*32)/bpmf;*/28.0f;
        float y_spawn =  /*((120-93) * 32)/bpmf;*/8.84f;
        bodyDef.position.set(x_spawn, y_spawn);

        // 차량 방향 (왼쪽)
        bodyDef.angle = MathUtils.degreesToRadians * 90;

        bodyDef.linearDamping = defaultLinearDamping;
        bodyDef.angularDamping = 20.0f;
        playerCar = world.createBody(bodyDef);

        FixtureDef fixtureDef = new FixtureDef();
        PolygonShape carShape = new PolygonShape();
        carShape.setAsBox(6.40f / PPM, 12.80f / PPM);
        fixtureDef.shape = carShape;
        fixtureDef.density = 3.5f;
        fixtureDef.friction = 0.3f;
        fixtureDef.restitution = 0.02f;

        Fixture fixture = playerCar.createFixture(fixtureDef);
        fixture.setUserData("player"); // 플레이어 태그

        carShape.dispose();
    }

    public void update(float delta) {
        float frameTime = Math.min(delta, 0.25f);
        accumulator += frameTime;
        while (accumulator >= TIME_STEP) {
            world.step(TIME_STEP, 8, 3);
            accumulator -= TIME_STEP;
        }

        if (gameState == GameState.PRE_START) {
            // 대기 중에는 랩타임/마모 진행 안 함
            lapTimeSeconds = 0f;
            if (playerCar != null) {
                playerCar.setLinearVelocity(0, 0);
                playerCar.setAngularVelocity(0);
            }
            if (startDelayRemaining > 0f) {
                startDelayRemaining -= delta;
            } else {
                if (startCountdown > 0f) {
                    startCountdown -= delta;
                    if (startCountdown < 0f) startCountdown = 0f;
                } else {
                    // 카운트다운 끝나면 GO 표시 -> OFF 표시 순으로 보여주고 나서 출발 허용
                    if (goTimer <= 0f && offTimer <= 0f) {
                        goTimer = goDisplayTime;
                        goJustStarted = true;
                    }
                }

                if (goTimer > 0f) {
                    if (goJustStarted) {
                        // 첫 프레임에는 감소하지 않음
                        goJustStarted = false;
                    } else {
                        goTimer -= delta;
                        if (goTimer < 0f) {
                            // 남은 시간을 offTimer에 이어서 사용
                            offTimer = offDisplayTime + goTimer;
                            goTimer = 0f;
                        }
                    }
                } else if (offTimer > 0f) {
                    offTimer -= delta;
                    if (offTimer < 0f) offTimer = 0f;
                }

                // offTimer까지 끝나야 출발 가능
                if (startCountdown <= 0f && goTimer <= 0f && offTimer <= 0f) {
                    startLightsDone = true;
                    gameState = GameState.NORMAL;
                }
            }
            // 대기 상태에서도 카메라를 차량 위치에 고정해 HUD와 차량 시작 위치를 일치시킴
            if (playerCar != null) {
                Vector2 pos = playerCar.getPosition();
                camera.position.set(pos.x, pos.y, 0f);
                cameraAngle = -playerCar.getAngle() * MathUtils.radiansToDegrees;
                camera.up.set(0, 1, 0);
                camera.direction.set(0, 0, -1);
                camera.rotate(cameraAngle);
                camera.update();
            }
            return;
        }

        lapTimeSeconds += delta;
        float speed = playerCar != null ? playerCar.getLinearVelocity().len() : 0f;
        if (speed > 0.5f) {
            durabilityPercent = Math.max(0f, durabilityPercent - durabilityDecayPerSecond * delta);
        }
        if (speed > tireWearThreshold) {
            float wearRate = getCompoundWearRate();
            tireDurabilityPercent = Math.max(0f, tireDurabilityPercent - wearRate * delta);
        }

        if (collisionTimer > 0) {
            collisionTimer -= delta;
            if (collisionTimer <= 0) {
                wasColliding = isColliding;
                isColliding = false;
            }
        }
        if (!startLightsDone && goTimer > 0f) {
            goTimer -= delta;
            if (goTimer <= 0f) {
                goTimer = 0f;
                startLightsDone = true;
            }
        }

        if (gameState == GameState.NORMAL) {
            if (pitEntryRect != null && pitEntryRect.contains(playerCar.getPosition())) {
                gameState = GameState.PIT_ENTERING;
                playerCar.setLinearVelocity(0, 0);
                playerCar.setAngularVelocity(0);
            }
            handleInput(delta);
            updateSteering(delta);
            updateFriction();
            limitSpeed();
            updateLapAndCheckpoints();
        } else {
            handlePitState(delta);
        }

        if (isColliding) {
            playerCar.setLinearDamping(collisionDamping);
            if (playerCar.getLinearVelocity().len() < 0.5f) {
                Vector2 forwardDirection = playerCar.getWorldVector(new Vector2(0, -0.3f));
                playerCar.applyLinearImpulse(forwardDirection, playerCar.getWorldCenter(), true);
            }
        }

        Vector2 forwardVector = new Vector2(0, cameraOffsetFromCar);
        Vector2 worldSpaceOffset = playerCar.getWorldVector(forwardVector);
        Vector2 targetPosition = new Vector2(playerCar.getPosition()).add(worldSpaceOffset);
        camera.position.x = MathUtils.lerp(camera.position.x, targetPosition.x, positionSmoothness * delta);
        camera.position.y = MathUtils.lerp(camera.position.y, targetPosition.y, positionSmoothness * delta);
        
        float targetAngle = -playerCar.getAngle() * MathUtils.radiansToDegrees;
        cameraAngle = MathUtils.lerpAngleDeg(cameraAngle, targetAngle, cameraRotationSmoothness * delta);
        camera.up.set(0, 1, 0);
        camera.direction.set(0, 0, -1);
        camera.rotate(cameraAngle);
        camera.update();

        if (USE_TILED_MAP && mapRenderer != null) {
            setExpandedMapView(camera);
        }
    }

    private void handleInput(float delta) {
        if (Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)) togglePause();
        boolean braking = Gdx.input.isKeyPressed(Input.Keys.SPACE);
        if (braking) playerCar.setLinearDamping(brakingLinearDamping);
        else if (isColliding) playerCar.setLinearDamping(collisionDamping);
        else if (grassContacts > 0) playerCar.setLinearDamping(grassDamping);
        else playerCar.setLinearDamping(defaultLinearDamping);

        Vector2 forwardNormal = playerCar.getWorldVector(new Vector2(0, 1));
        float forwardSpeed = playerCar.getLinearVelocity().dot(forwardNormal);
        float currentSpeed = playerCar.getLinearVelocity().len();
        float targetAcceleration = 0;
        boolean movingForward = false;
        boolean movingReverse = false;

        if (Gdx.input.isKeyPressed(Input.Keys.UP) || Gdx.input.isKeyPressed(Input.Keys.W)) {
            targetAcceleration = forwardAcceleration;
            movingForward = true;
        }
        if (Gdx.input.isKeyPressed(Input.Keys.DOWN) || Gdx.input.isKeyPressed(Input.Keys.S)) {
            targetAcceleration = -reverseAcceleration;
            movingReverse = true;
        }
        if (braking) {
            targetAcceleration = 0f;
            Vector2 vel = playerCar.getLinearVelocity();
            float speed = vel.len();
            if (speed > 0.05f) {
                // 부드러운 감속: 질량·속도 비례 역방향 힘
                Vector2 brakeForce = vel.nor().scl(-playerCar.getMass() * 1.8f * delta);
                playerCar.applyForceToCenter(brakeForce, true);
            }
            playerCar.setAngularVelocity(playerCar.getAngularVelocity() * 0.93f);
        }
        currentAcceleration = MathUtils.lerp(currentAcceleration, targetAcceleration, accelerationSmoothness * delta);
        if (Math.abs(currentAcceleration) > 0.1f) {
            Vector2 forceVector = playerCar.getWorldVector(new Vector2(0, currentAcceleration));
            playerCar.applyForceToCenter(forceVector, true);
        }

        if (currentSpeed >= minSpeedForTurn && (movingForward || movingReverse)) {
             // (Optional: speed factor logic)
        }
    }

    private void updateSteering(float delta) {
        float targetAngularVelocity = 0;
        float maxAngularVelocity = MathUtils.degreesToRadians * 190;
        Vector2 forwardNormal = playerCar.getWorldVector(new Vector2(0, 1));
        float forwardSpeed = playerCar.getLinearVelocity().dot(forwardNormal);
        boolean movingReverse = Gdx.input.isKeyPressed(Input.Keys.DOWN) || Gdx.input.isKeyPressed(Input.Keys.S);

        if (Gdx.input.isKeyPressed(Input.Keys.LEFT) || Gdx.input.isKeyPressed(Input.Keys.A)) {
            targetAngularVelocity = (movingReverse && forwardSpeed < -0.5f) ? -maxAngularVelocity : maxAngularVelocity;
        } else if (Gdx.input.isKeyPressed(Input.Keys.RIGHT) || Gdx.input.isKeyPressed(Input.Keys.D)) {
            targetAngularVelocity = (movingReverse && forwardSpeed < -0.5f) ? maxAngularVelocity : -maxAngularVelocity;
        }
        float currentAngularVelocity = playerCar.getAngularVelocity();
        float velocityChange = targetAngularVelocity - currentAngularVelocity;
        float impulse = playerCar.getInertia() * velocityChange;
        playerCar.applyAngularImpulse(impulse, true);
    }

    private void updateFriction() {
        boolean isSteering = Gdx.input.isKeyPressed(Input.Keys.LEFT) || Gdx.input.isKeyPressed(Input.Keys.RIGHT) || Gdx.input.isKeyPressed(Input.Keys.A) || Gdx.input.isKeyPressed(Input.Keys.D);
        float gripFactor = isSteering ? 0.9f : 1.0f;
        Vector2 lateralVelocity = getLateralVelocity();
        v2_tmp1.set(lateralVelocity).scl(-playerCar.getMass() * grip * gripFactor);
        playerCar.applyForceToCenter(v2_tmp1, true);
        Vector2 forwardVelocity = getForwardVelocity();
        float forwardSpeed = forwardVelocity.len();
        if (forwardSpeed > 0.1f) {
            float dragCoefficient = 0.05f * forwardSpeed;
            v2_tmp1.set(forwardVelocity).scl(-dragCoefficient * playerCar.getMass());
            playerCar.applyForceToCenter(v2_tmp1, true);
        }
    }

    private void limitSpeed() {
        Vector2 forwardNormal = playerCar.getWorldVector(new Vector2(0, 1));
        float forwardSpeed = playerCar.getLinearVelocity().dot(forwardNormal);
        float speed = playerCar.getLinearVelocity().len();
        if (forwardSpeed > 0 && speed > maxForwardSpeed) {
            playerCar.setLinearVelocity(playerCar.getLinearVelocity().scl(maxForwardSpeed / speed));
        } else if (forwardSpeed < 0 && speed > maxReverseSpeed) {
            playerCar.setLinearVelocity(playerCar.getLinearVelocity().scl(maxReverseSpeed / speed));
        }
    }

    private void handlePitState(float delta) {
        if (gameState == GameState.PIT_ENTERING) {
            if (pitServicePos != null) {
                playerCar.setLinearVelocity(0, 0);
                playerCar.setAngularVelocity(0);
                float angRad = pitServiceAngleDeg * MathUtils.degreesToRadians;
                playerCar.setTransform(pitServicePos, angRad);
            }
            pitSelectedCompound = tireCompound;
            pitPointerT = 0.5f;
            pitPointerDir = 1f;
            pitPointerSpeed = 1.5f;
            pitMiniGameLocked = false;
            lastPitResult = "";
            pitServiceTimeTotal = 0f;
            pitServiceTimeRemaining = 0f;
            gameState = GameState.PIT_MINIGAME;
        } else if (gameState == GameState.PIT_MINIGAME) {
            if (!pitMiniGameLocked) {
                pitPointerT += pitPointerSpeed * pitPointerDir * delta;
                if (pitPointerT > 1f) { pitPointerT = 1f; pitPointerDir = -1f; }
                if (pitPointerT < 0f) { pitPointerT = 0f; pitPointerDir = 1f; }

                // 숫자열(상단/넘패드) + 예비키로 선택 확실히 처리
                if (keyHit(Input.Keys.NUM_1, Input.Keys.NUMPAD_1, Input.Keys.NUM_4, Input.Keys.Q)) pitSelectedCompound = "soft";
                if (keyHit(Input.Keys.NUM_2, Input.Keys.NUMPAD_2, Input.Keys.NUM_5, Input.Keys.W)) pitSelectedCompound = "medium";
                if (keyHit(Input.Keys.NUM_3, Input.Keys.NUMPAD_3, Input.Keys.NUM_6, Input.Keys.E)) pitSelectedCompound = "hard";

                if (Gdx.input.isKeyJustPressed(Input.Keys.SPACE) || Gdx.input.isKeyJustPressed(Input.Keys.ENTER)) {
                    float grade = pitPointerT;
                    float baseServiceTime = 3.0f + 4.0f * (1f - durabilityPercent / 100f);
                    if (grade >= 0.40f && grade <= 0.60f) { lastPitResult = "Perfect"; pitServiceTimeTotal = baseServiceTime * 0.7f; }
                    else if ((grade >= 0.25f && grade < 0.40f) || (grade > 0.60f && grade <= 0.75f)) { lastPitResult = "Good"; pitServiceTimeTotal = baseServiceTime; }
                    else { lastPitResult = "Bad"; pitServiceTimeTotal = baseServiceTime * 1.5f; }
                    pitServiceTimeRemaining = pitServiceTimeTotal;
                    pitPointerSpeed = 0f;
                    pitMiniGameLocked = true;
                }
            }
            if (pitServiceTimeRemaining > 0f) {
                pitServiceTimeRemaining -= delta;
                if (pitServiceTimeRemaining <= 0f) {
                    durabilityPercent = 100f;
                    tireDurabilityPercent = 100f;
                    setTireCompound(pitSelectedCompound);
                    gameState = GameState.PIT_EXITING;
                }
            }
        } else if (gameState == GameState.PIT_EXITING) {
            if (pitExitPos != null) {
                Vector2 pos = playerCar.getPosition();
                Vector2 dir = new Vector2(pitExitPos).sub(pos);
                if (dir.len() < 0.2f) {
                    playerCar.setLinearVelocity(0, 0);
                    playerCar.setTransform(pitExitPos, pitExitAngleDeg * MathUtils.degreesToRadians);
                    gameState = GameState.NORMAL;
                } else {
                    dir.nor().scl(1.5f);
                    playerCar.setLinearVelocity(dir);
                    playerCar.setTransform(pos.add(dir.scl(delta)), playerCar.getAngle());
                }
            } else {
                gameState = GameState.NORMAL;
            }
        }
    }

    private boolean keyHit(int... keys) {
        for (int k : keys) {
            if (Gdx.input.isKeyJustPressed(k) || Gdx.input.isKeyPressed(k)) return true;
        }
        return false;
    }

    private Vector2 getLateralVelocity() {
        v2_tmp1.set(playerCar.getWorldVector(new Vector2(1, 0)));
        float rightSpeed = playerCar.getLinearVelocity().dot(v2_tmp1);
        return v2_tmp1.scl(rightSpeed);
    }

    private Vector2 getForwardVelocity() {
        v2_tmp2.set(playerCar.getWorldVector(new Vector2(0, 1)));
        float forwardSpeed = playerCar.getLinearVelocity().dot(v2_tmp2);
        return v2_tmp2.scl(forwardSpeed);
    }

    @Override
    public void render(float delta) {
        if (paused && Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)) togglePause();
        if (!paused) update(delta);

        Gdx.gl.glClearColor(0.1f, 0.1f, 0.1f, 1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        if (USE_TILED_MAP && mapRenderer != null) {
            setExpandedMapView(camera);
            mapRenderer.render();
        }

        batch.setProjectionMatrix(camera.combined);
        batch.begin();
        Vector2 carPos = playerCar.getPosition();
        float carWidth = 12.80f / PPM;
        float carHeight = 25.60f / PPM;
        batch.draw(carTexture,
            carPos.x - carWidth / 2, carPos.y - carHeight / 2,
            carWidth / 2, carHeight / 2,
            carWidth, carHeight,
            1, 1,
            playerCar.getAngle() * MathUtils.radiansToDegrees,
            0, 0, carTexture.getWidth(), carTexture.getHeight(),
            false, false);
        batch.end();

        drawLapTimeHud();
        drawMinimapHud();
        drawSpeedHud();
        drawDurabilityHud();
        drawTireHud();
        drawRaceStatusHud();
        drawPitMinigameHud();
        drawStartLightsHud();

        if (paused) drawPauseOverlay();
    }

    private void drawLapTimeHud() {
        if (lapBestBgTexture == null || lapLastBgTexture == null || debugFont == null || hudCamera == null) return;

        float padding = 16f;
        float frameX = hudCamera.viewportWidth - minimapFrameSize - minimapPadding;
        float frameY = hudCamera.viewportHeight - minimapFrameSize - minimapPadding;
        float bgWidth = lapBestBgTexture.getWidth();
        float bgHeight = lapBestBgTexture.getHeight();
        float gap = 12f;
        float bestX = frameX + minimapFrameSize - bgWidth;
        float bestY = frameY - bgHeight - gap;
        float spacingY = 12f;
        float lastX = bestX;
        float lastY = bestY - bgHeight - spacingY;

        float textOffsetX = 160f;
        float textOffsetY = 35f;

        batch.setProjectionMatrix(hudCamera.combined);
        batch.begin();
        batch.draw(lapBestBgTexture, bestX, bestY);
        batch.draw(lapLastBgTexture, lastX, lastY);
        debugFont.draw(batch, formatLapTime(bestLapTime), bestX + textOffsetX, bestY + textOffsetY);
        debugFont.draw(batch, formatLapTime(lastLapTime), lastX + textOffsetX, lastY + textOffsetY);
        batch.end();
    }

    private void drawMinimapHud() {
        if (minimapRegion == null || hudCamera == null || minimapCarTexture == null || playerCar == null) return;

        float hudX = minimapPadding;
        float hudY = hudCamera.viewportHeight - minimapFrameSize - minimapPadding;
        float hudW = minimapFrameSize - (minimapInset * 2f);
        float hudH = hudW;
        float frameX = hudCamera.viewportWidth - minimapFrameSize - minimapPadding;
        float frameY = hudCamera.viewportHeight - minimapFrameSize - minimapPadding;

        float scaleX = mapWorldWidth > 0 ? hudW / mapWorldWidth : 1f;
        float scaleY = mapWorldHeight > 0 ? hudH / mapWorldHeight : 1f;

        float px = (frameX + minimapInset) + playerCar.getPosition().x * scaleX;
        float py = (frameY + minimapInset) + playerCar.getPosition().y * scaleY;
        float iconSize = 10f;

        batch.setProjectionMatrix(hudCamera.combined);
        batch.begin();
        if (minimapFrameTexture != null) {
            batch.draw(minimapFrameTexture, frameX, frameY, minimapFrameSize, minimapFrameSize);
        }
        batch.draw(minimapRegion, frameX + minimapInset, frameY + minimapInset, hudW, hudH);
        batch.draw(
            minimapCarTexture,
            px - iconSize / 2f,
            py - iconSize / 2f,
            iconSize / 2f,
            iconSize / 2f,
            iconSize,
            iconSize,
            1f,
            1f,
            playerCar.getAngle() * MathUtils.radiansToDegrees,
            0,
            0,
            minimapCarTexture.getWidth(),
            minimapCarTexture.getHeight(),
            false,
            false
        );
        batch.end();
    }
    //차량 속도계
    private void drawSpeedHud() {
        if (speedHudTexture == null || hudCamera == null) return;
        float texW = speedHudTexture.getWidth();
        float texH = speedHudTexture.getHeight();
        float padding = 16f;
        float x = (hudCamera.viewportWidth - texW) * 0.5f;
        float y = padding;

        float speedScale = 16.0f;
        float speedKmh = 0f;
        if (playerCar != null) speedKmh = playerCar.getLinearVelocity().len() * 3.6f*speedScale;
        int speedInt = Math.round(speedKmh);
        int rank = Math.max(1, playerRank);
        String rankText = rank + getRankSuffix(rank);

        BitmapFont font = speedFont != null ? speedFont : debugFont;
        GlyphLayout layout = new GlyphLayout();

        batch.setProjectionMatrix(hudCamera.combined);
        batch.begin();
        batch.draw(speedHudTexture, x, y);

        layout.setText(font, String.valueOf(speedInt));
        float speedX = x + 60f - layout.width * 0.5f;
        float speedY = y + 78f;
        font.draw(batch, layout, speedX, speedY);

        layout.setText(font, rankText);
        float rankX = x + 260f - layout.width * 0.5f;
        float rankY = y + 78f;
        font.draw(batch, layout, rankX, rankY);

        batch.end();
    }

    private void drawStartLightsHud() {
        if (startLightsDone || hudCamera == null) return;
        if (startDelayRemaining > 0f) return; // 로딩 직후 대기 시간
        // 4개 이미지가 나열되어 순차로 켜지도록 매핑 (1111 -> 3111 -> 3311 -> 3331 -> 3333 -> 1111(OFF))
        Texture[] lamps = new Texture[4];
        // 기본은 모두 1번
        lamps[0] = light1Texture;
        lamps[1] = light1Texture;
        lamps[2] = light1Texture;
        lamps[3] = light1Texture;

        if (offTimer > 0f && goTimer <= 0f) { // OFF 단계: 1111
            lamps[0] = light1Texture;
            lamps[1] = light1Texture;
            lamps[2] = light1Texture;
            lamps[3] = light1Texture;
        } else if (goTimer > 0f || startCountdown <= 0f) { // 3333
            lamps[0] = light3Texture;
            lamps[1] = light3Texture;
            lamps[2] = light3Texture;
            lamps[3] = light3Texture;
        } else if (startCountdown <= 1f) { // 3331
            lamps[0] = light3Texture;
            lamps[1] = light3Texture;
            lamps[2] = light3Texture;
            lamps[3] = light1Texture;
        } else if (startCountdown <= 2f) { // 3311
            lamps[0] = light3Texture;
            lamps[1] = light3Texture;
            lamps[2] = light1Texture;
            lamps[3] = light1Texture;
        } else if (startCountdown <= 3f) { // 3111
            lamps[0] = light3Texture;
            lamps[1] = light1Texture;
            lamps[2] = light1Texture;
            lamps[3] = light1Texture;
        } // else 1111 그대로

        float texW = light1Texture != null ? light1Texture.getWidth() :
                     light2Texture != null ? light2Texture.getWidth() :
                     light3Texture != null ? light3Texture.getWidth() :
                     lightGoTexture != null ? lightGoTexture.getWidth() : 0f;
        float texH = light1Texture != null ? light1Texture.getHeight() :
                     light2Texture != null ? light2Texture.getHeight() :
                     light3Texture != null ? light3Texture.getHeight() :
                     lightGoTexture != null ? lightGoTexture.getHeight() : 0f;
        if (texW == 0 || texH == 0) return;

        float scale = 0.75f; // 조금 더 작게
        float drawW = texW * scale;
        float drawH = texH * scale;
        float gap = 8f;
        float totalW = drawW * 4f + gap * 3f;
        float startX = (hudCamera.viewportWidth - totalW) * 0.5f;
        float y = hudCamera.viewportHeight - drawH; // 화면 맨 위에 맞닿게

        batch.setProjectionMatrix(hudCamera.combined);
        batch.begin();
        float x = startX;
        for (int i = 0; i < 4; i++) {
            Texture t = lamps[i];
            if (t != null) {
                batch.draw(t, x, y, drawW, drawH);
            }
            x += drawW + gap;
        }
        batch.end();
    }

    private String getRankSuffix(int rank) {
        if (rank % 100 >= 11 && rank % 100 <= 13) return "th";
        switch (rank % 10) {
            case 1: return "st";
            case 2: return "nd";
            case 3: return "rd";
            default: return "th";
        }
    }

    private void drawPitMinigameHud() {
        if (gameState != GameState.PIT_MINIGAME) return;
        if (pitPanelTexture == null || pitBarTexture == null || hudCamera == null) return;
        float panelW = pitPanelTexture.getWidth();
        float panelH = pitPanelTexture.getHeight();
        float panelX = (hudCamera.viewportWidth - panelW) * 0.5f;
        float panelY = (hudCamera.viewportHeight - panelH) * 0.5f;
        float barW = pitBarTexture.getWidth();
        float barH = pitBarTexture.getHeight();
        float barX = (hudCamera.viewportWidth - barW) * 0.5f;
        // 바/포인터를 패널 아래쪽으로 내려 겹침 방지
        float barY = panelY - 60f;

        BitmapFont font = speedFont != null ? speedFont : debugFont;
        batch.setProjectionMatrix(hudCamera.combined);
        batch.begin();
        batch.draw(pitPanelTexture, panelX, panelY);
        batch.draw(pitBarTexture, barX, barY);
        float pointerX = barX + pitPointerT * barW;
        if (pitPointerTexture != null) {
            batch.draw(pitPointerTexture, pointerX - pitPointerTexture.getWidth() / 2f, barY - 10f);
        }
        font.draw(batch, "Pit: " + pitSelectedCompound.toUpperCase(), panelX + 24f, panelY + panelH - 20f);
        if (!lastPitResult.isEmpty()) {
            font.draw(batch, "Result: " + lastPitResult, panelX + 24f, panelY + 40f);
        }
        if (pitServiceTimeRemaining > 0f) {
            font.draw(batch, String.format("Service: %.1fs", Math.max(0f, pitServiceTimeRemaining)), barX, barY - 10f);
        }
        batch.end();
    }

    private float getCompoundWearRate() {
        switch (tireCompound.toLowerCase()) {
            case "soft": return softWearRate;
            case "hard": return hardWearRate;
            default: return mediumWearRate;
        }
    }

    // 타이어 교체 시 호출해서 컴파운드/텍스처/내구도 리셋
    private void setTireCompound(String compound) {
        tireCompound = compound.toLowerCase();
        switch (tireCompound) {
            case "soft":
                if (tireCompoundSoftTexture != null) tireCompoundTexture = tireCompoundSoftTexture;
                break;
            case "hard":
                if (tireCompoundHardTexture != null) tireCompoundTexture = tireCompoundHardTexture;
                break;
            default:
                tireCompound = "medium";
                if (tireCompoundMediumTexture != null) tireCompoundTexture = tireCompoundMediumTexture;
                break;
        }
        tireDurabilityPercent = 100f;
    }

    //차량 내구도 감소 로직
    

    private void drawTireHud() {
        if (tireLabelTexture == null || tireBgTexture == null || tireFgTexture == null || tireCompoundTexture == null || hudCamera == null) return;

        float padding = 24f;
        float verticalOffset = 60f; // 아래로 더 내림 (compound 라벨을 화면 하단 가까이)
        float labelW = tireLabelTexture.getWidth();
        float labelH = tireLabelTexture.getHeight();
        float bgW = tireBgTexture.getWidth();
        float bgH = tireBgTexture.getHeight();
        float fgMaxH = tireFgTexture.getHeight();
        float fgOffsetX = 0f;

        // 오른쪽 하단 배치
        float bgX = hudCamera.viewportWidth - bgW - padding;
        float bgY = padding + verticalOffset;
        float labelX = hudCamera.viewportWidth - labelW - padding;
        float labelY = bgY + bgH + 12f;
        float cmpW = tireCompoundTexture != null ? tireCompoundTexture.getWidth() : 0f;
        float cmpH = tireCompoundTexture != null ? tireCompoundTexture.getHeight() : 0f;
        float cmpX = bgX + (bgW - cmpW) * 0.5f;
        float cmpY = bgY - cmpH - 4f; // 라벨을 더 아래로

        float fgHeight = Math.max(0f, Math.min(100f, tireDurabilityPercent)) / 100f * fgMaxH;
        float fgStartY = bgY; // BG와 동일 Y에서 시작해 정확히 겹침

        batch.setProjectionMatrix(hudCamera.combined);
        batch.begin();
        batch.draw(tireLabelTexture, labelX, labelY);
        batch.draw(tireBgTexture, bgX, bgY);
        batch.draw(tireFgTexture, bgX + fgOffsetX, fgStartY, tireFgTexture.getWidth(), fgHeight);
        batch.draw(tireCompoundTexture, cmpX, cmpY);
        batch.end();
    }
private void drawDurabilityHud() {
        if (durabilityLabelTexture == null || durabilityBgTexture == null || durabilityFgTexture == null || hudCamera == null) return;

        float padding = 24f;
        float labelW = durabilityLabelTexture.getWidth();
        float labelH = durabilityLabelTexture.getHeight();
        float bgW = durabilityBgTexture.getWidth();
        float bgH = durabilityBgTexture.getHeight();
        float fgMaxH = durabilityFgTexture.getHeight();
        // BG/FG 실제 크기에 맞춰 중앙 정렬: X는 가운데, Y는 BG 안에서 가능한 한 가운데(음수 방지)
        float fgOffsetX = Math.max(0f, (bgW - durabilityFgTexture.getWidth()) * 0.5f);
        float fgOffsetY = Math.max(0f, (bgH - fgMaxH) * 0.5f);

        // 좌하단 기준 배치
        float bgX = padding;
        float bgY = padding;
        float labelX = padding;
        float labelY = bgY + bgH + 12f;

        float fgHeight = Math.max(0f, Math.min(100f, durabilityPercent)) / 100f * fgMaxH;

        batch.setProjectionMatrix(hudCamera.combined);
        batch.begin();
        batch.draw(durabilityLabelTexture, labelX, labelY);
        batch.draw(durabilityBgTexture, bgX, bgY);
        batch.draw(durabilityFgTexture, bgX + fgOffsetX, bgY + fgOffsetY, durabilityFgTexture.getWidth(), fgHeight);
        batch.end();
    }

    private void drawRaceStatusHud() {
        if (raceStatusTexture == null || debugFont == null || hudCamera == null) return;
        float padding = 16f;
        float texW = raceStatusTexture.getWidth();
        float texH = raceStatusTexture.getHeight();
        float x = padding; // 왼쪽 정렬
        float y = hudCamera.viewportHeight - texH - padding; // 상단에서 내려옴


        batch.setProjectionMatrix(hudCamera.combined);
        batch.begin();
        batch.draw(raceStatusTexture, x, y);

        // 텍스트 위치는 대략적인 비율로 배치 (player box / lap numbers)
        float centerY = y + texH * 0.55f;
        GlyphLayout layout = new GlyphLayout();
        BitmapFont font = raceStatusFont != null ? raceStatusFont : debugFont;

        // Player label
        String playerText = "P" + playerIndex;
        layout.setText(font, playerText);
        float playerX = x + texW * 0.16f - layout.width * 0.5f;
        float playerY = centerY + layout.height * 0.5f;
        font.draw(batch, layout, playerX, playerY);

        // Current lap
        String currentLapText = String.valueOf(Math.max(1, currentLap + 1));
        layout.setText(font, currentLapText);
        float lapCurX = x + texW * 0.72f - layout.width * 0.5f; // 오른쪽으로 소폭 이동
        float lapCurY = centerY + layout.height * 0.4f;
        font.draw(batch, layout, lapCurX, lapCurY);

        // Total lap
        String totalLapText = String.valueOf(Math.max(totalLaps, currentLap + 1));
        layout.setText(font, totalLapText);
        float lapTotX = x + texW * 0.90f - layout.width * 0.5f; // 오른쪽으로 소폭 이동
        float lapTotY = centerY + layout.height * 0.4f;
        font.draw(batch, layout, lapTotX, lapTotY);

        batch.end();
    }


    @Override
    public void resize(int width, int height) {
        viewport.update(width, height, true);
        if (pauseStage != null) pauseStage.getViewport().update(width, height, true);
        if (hudCamera != null) {
            hudCamera.setToOrtho(false, width, height);
            hudCamera.update();
        }
    }

    @Override
    public void dispose() {
        world.dispose();
        box2DDebugRenderer.dispose();
        if (map != null) map.dispose();
        if (mapRenderer != null) mapRenderer.dispose();
        batch.dispose();
        if (pauseStage != null) pauseStage.dispose();
        if (pauseSkin != null) pauseSkin.dispose();
        if (debugFont != null) debugFont.dispose();
        if (shapeRenderer != null) shapeRenderer.dispose();
        if (lapBestBgTexture != null) lapBestBgTexture.dispose();
        if (lapLastBgTexture != null) lapLastBgTexture.dispose();
        if (minimapFrameTexture != null) minimapFrameTexture.dispose();
        if (minimapCarTexture != null) minimapCarTexture.dispose();
        if (minimapFbo != null) minimapFbo.dispose();
        if (durabilityLabelTexture != null) durabilityLabelTexture.dispose();
        if (durabilityBgTexture != null) durabilityBgTexture.dispose();
        if (durabilityFgTexture != null) durabilityFgTexture.dispose();
        if (raceStatusTexture != null) raceStatusTexture.dispose();
        if (speedHudTexture != null) speedHudTexture.dispose();
        if (raceStatusFont != null && raceStatusFont != debugFont) raceStatusFont.dispose();
        if (speedFont != null && speedFont != debugFont) speedFont.dispose();
        if (tireLabelTexture != null) tireLabelTexture.dispose();
        if (tireBgTexture != null) tireBgTexture.dispose();
        if (tireFgTexture != null) tireFgTexture.dispose();
        if (tireCompoundSoftTexture != null) tireCompoundSoftTexture.dispose();
        if (tireCompoundMediumTexture != null) tireCompoundMediumTexture.dispose();
        if (tireCompoundHardTexture != null) tireCompoundHardTexture.dispose();
        if (pitPanelTexture != null) pitPanelTexture.dispose();
        if (pitBarTexture != null) pitBarTexture.dispose();
        if (pitPointerTexture != null) pitPointerTexture.dispose();
    }

    private void togglePause() {
        paused = !paused;
        if (paused) {
            Gdx.input.setInputProcessor(pauseStage);
            buildPauseUI();
        } else {
            Gdx.input.setInputProcessor(null);
            if (pauseStage != null) pauseStage.clear();
        }
    }

    private void buildPauseUI() {
        pauseStage.clear();
        Table root = new Table();
        root.setFillParent(true);
        root.setBackground(pauseSkin.getDrawable("bg"));
        pauseStage.addActor(root);
        Table panel = new Table();
        panel.setBackground(pauseSkin.getDrawable("panel"));
        panel.defaults().pad(8).width(300).height(44);
        Label title = new Label("Pause", pauseSkin, "title");
        TextButton resume = new TextButton("Resume", pauseSkin);
        TextButton mainMenu = new TextButton("Main Menu", pauseSkin);
        TextButton exit = new TextButton("Exit", pauseSkin);
        resume.addListener(new com.badlogic.gdx.scenes.scene2d.utils.ClickListener(){
            @Override public void clicked(InputEvent event, float x, float y){ togglePause(); }
        });
        mainMenu.addListener(new com.badlogic.gdx.scenes.scene2d.utils.ClickListener(){
            @Override public void clicked(InputEvent event, float x, float y){
                if (gameRef != null) gameRef.setScreen(new MainMenuScreen(gameRef)); else Gdx.app.exit();
            }
        });
        exit.addListener(new com.badlogic.gdx.scenes.scene2d.utils.ClickListener(){
            @Override public void clicked(InputEvent event, float x, float y){ Gdx.app.exit(); }
        });
        panel.add(title).row();
        panel.add(resume).row();
        panel.add(mainMenu).row();
        panel.add(exit).row();
        root.add(panel).center();
    }

    private void drawPauseOverlay() {
        if (pauseStage != null) {
            pauseStage.act(Gdx.graphics.getDeltaTime());
            pauseStage.draw();
        }
    }

    @Override public void hide() {}
    @Override public void pause() {}
    @Override public void resume() {}
}   
