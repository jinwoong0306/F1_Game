 
1. 작업 개요 – 기본 문장 블록

본 변경사항 문서는 프로젝트 진행 과정에서 개인이 담당한 작업을 정리하기 위해 작성되었다.

단순 기능 구현 내역뿐 아니라 구조적 이해와 문서화 작업을 함께 포함한다.

코드 변경과 직접적으로 연결되지 않는 설계적 고려 사항도 기록 대상으로 삼았다.

프로젝트 전반의 흐름을 이해하는 과정에서 확인된 문제점과 개선 방향을 정리하였다.

팀 단위 협업 상황에서 공유가 필요한 맥락을 남기는 것을 하나의 목표로 두었다.

단기적인 과제 수행뿐 아니라 이후 유지보수를 고려한 관점에서 내용을 정리하였다.

본 문서는 향후 작업자가 프로젝트 구조를 빠르게 파악하는 데 참고 자료로 활용될 수 있다.

실제 코드 구조와 디렉토리 구성을 기준으로 작성되었다.

2. 작업 범위 정의 – 기본 문장 블록

본 작업에서 다룬 범위는 프론트엔드와 백엔드 전반의 구조 이해를 포함한다.

특정 기능 구현보다는 전체 흐름을 파악하는 데 중점을 두었다.

데이터 흐름과 상태 관리 방식에 대한 이해를 주요 작업 범위로 설정하였다.

API 연동 구조와 요청·응답 흐름을 분석 대상으로 삼았다.

코드 레벨의 변경뿐 아니라 문서 정리와 설계 기록도 작업 범위에 포함하였다.

실제 실행 로직보다는 구조적 의사결정의 배경을 정리하는 데 집중하였다.

프로젝트 확장 시 영향을 받을 수 있는 영역을 사전에 파악하는 것을 목표로 하였다.

3. 디렉토리 구조 이해 – 기본 문장 블록

프로젝트는 역할별 디렉토리 분리를 통해 구조적 가독성을 확보하고 있다.

각 디렉토리는 명확한 책임 단위를 기준으로 구성되어 있다.

프론트엔드 영역은 화면 단위와 컴포넌트 단위로 분리되어 있다.

백엔드 영역은 서비스 로직과 계산 로직이 구분되어 설계되어 있다.

문서 및 설정 파일은 코드와 분리하여 관리되고 있다.

이러한 구조는 협업 과정에서 충돌을 줄이는 데 도움이 된다.

향후 기능 추가 시 디렉토리 확장이 비교적 용이한 형태로 판단된다.

4. 데이터 모델 및 타입 설계 – 기본 문장 블록

데이터 모델은 실제 서비스 흐름을 기준으로 정의되어 있다.

공통적으로 사용되는 데이터 구조는 타입으로 분리되어 관리되고 있다.

타입 정의를 통해 코드 가독성과 안정성을 확보하고자 하였다.

확장 가능성을 고려하여 일부 필드는 선택적으로 설계되어 있다.

중복 정의를 피하기 위해 공통 타입 사용을 우선시하였다.

타입 설계 과정에서 실제 사용 빈도를 고려하였다.

5. 상태 관리 및 데이터 흐름 – 기본 문장 블록

상태 관리는 전역 상태와 화면 단위 상태로 구분되어 있다.

전역 상태는 여러 화면에서 공유되는 데이터를 중심으로 구성되어 있다.

사용자 입력은 상태를 통해 일관되게 관리된다.

API 요청 이전 단계에서 데이터 정합성을 확보하도록 설계되어 있다.

응답 데이터는 화면 렌더링에 필요한 형태로 가공된다.

이러한 흐름은 디버깅과 유지보수 측면에서 유리하다.


변경사항 2. 프로젝트 구조 및 흐름 이해 정리

프로젝트 전반의 디렉토리 구조를 검토하고 각 폴더의 역할을 정리하였다.

프론트엔드와 백엔드가 명확히 분리되어 있으며, 책임 단위에 따라 파일이 구성되어 있음을 확인하였다.

단순히 파일이 나열된 구조가 아니라, 기능 확장을 고려한 형태로 설계되어 있다는 점을 파악하였다.

프론트엔드 영역에서는 라우팅 단위와 컴포넌트 단위가 비교적 명확히 구분되어 있다.

공통 UI 컴포넌트는 재사용을 전제로 구성되어 있으며, 스타일 및 동작 일관성을 유지하는 데 목적이 있다.

백엔드 영역에서는 서비스 로직과 계산 로직이 분리되어 있어 유지보수 측면에서 장점이 있다고 판단하였다.

최적화 로직, 데이터 수집 로직, 외부 연동 로직이 각각 독립된 파일로 관리되고 있음을 확인하였다.

이러한 구조는 팀 단위 협업 시 역할 분담을 명확히 하는 데 도움이 된다.

디렉토리 구조를 먼저 이해한 후 코드 흐름을 따라가는 방식이 전체 파악에 효과적이었다.

초기에는 구조가 복잡하게 느껴질 수 있으나, 역할 단위로 분리되어 있어 익숙해지면 가독성이 높다.

향후 기능 추가 시 기존 구조를 크게 변경하지 않고도 확장이 가능할 것으로 판단하였다.
변경사항 3. 데이터 흐름 및 상태 관리 구조 정리

사용자 입력부터 결과 출력까지의 데이터 흐름을 단계별로 정리하였다.

화면 단위 입력은 로컬 상태로 관리되며, 여러 화면에서 공유되는 데이터는 전역 상태로 분리되어 있다.

전역 상태는 공통 store를 통해 관리되어 데이터 일관성을 유지한다.

상태 변경 시점과 API 호출 시점을 명확히 구분하려는 설계 의도가 보인다.

API 요청 전에는 입력 데이터의 형태를 정규화하여 예외 상황을 최소화하도록 구성되어 있다.

응답 데이터는 화면 표시 목적에 맞게 가공되어 사용된다.

이 과정에서 불필요한 데이터는 필터링되어 전달된다.

상태 흐름이 단방향으로 유지되어 디버깅 시 추적이 용이하다.

화면 렌더링과 데이터 처리 로직이 분리되어 있어 가독성이 높다.

이러한 구조는 기능 추가 시 기존 코드에 미치는 영향을 줄여준다.

향후 상태 규모가 커질 경우에도 확장 가능한 형태로 판단된다.

변경사항 4. API 연동 및 요청·응답 구조 분석

프론트엔드와 백엔드 간의 API 연동 흐름을 중심으로 구조를 정리하였다.

API 호출은 특정 컴포넌트에 분산되지 않고, 비교적 일관된 방식으로 관리되고 있다.

요청 데이터는 화면 입력값을 그대로 전달하기보다, 내부 규칙에 맞게 가공된 형태로 전달된다.

이를 통해 백엔드에서의 데이터 처리 부담을 줄이도록 설계되어 있다.

응답 데이터는 단순 결과값뿐 아니라, 화면 구성에 필요한 부가 정보를 함께 포함한다.

에러 발생 시를 고려한 응답 구조가 정의되어 있어 예외 처리 흐름을 파악하기 수월하다.

API 실패 상황에서도 화면이 완전히 중단되지 않도록 방어 로직이 고려되어 있다.

요청과 응답의 책임 범위가 명확히 구분되어 있다는 점이 인상적이었다.

이러한 구조는 API 변경 시 영향을 받는 범위를 제한하는 데 도움이 된다.

향후 API 엔드포인트가 추가되더라도 동일한 패턴을 유지할 수 있을 것으로 보인다.

전체적으로 유지보수와 확장을 모두 고려한 연동 구조로 판단된다.

변경사항 1. GameScreen 구조 및 게임 루프 이해

F1_Game 프로젝트에서 레이스 진행의 핵심을 담당하는 GameScreen 클래스의 역할을 정리하였다.

GameScreen은 실제 레이싱 로직이 수행되는 메인 화면으로, 게임 흐름의 중심에 위치한다.

화면 진입 시 트랙 맵 로딩, 차량 초기화, 카메라 설정이 함께 이루어진다.

libGDX의 Screen 인터페이스 구조를 기반으로 lifecycle 메서드들이 활용되고 있다.

render() 메서드를 중심으로 매 프레임마다 게임 상태가 갱신된다.

입력 처리, 물리 계산, 화면 렌더링이 하나의 루프 안에서 순차적으로 수행된다.

update 로직과 draw 로직이 분리되어 있어 코드 흐름을 따라가기 비교적 수월하다.

GameScreen 내부에서 여러 시스템(차량, 체크포인트, HUD)이 함께 동작한다.

각 시스템이 GameScreen에 과도하게 종속되지 않도록 분리할 필요성도 함께 느꼈다.

게임 루프 구조를 이해한 이후 전체 코드 흐름이 명확해졌다.

변경사항 2. 차량 이동 및 조작 로직 정리

플레이어 차량의 이동과 조작 로직을 중심으로 코드를 분석하였다.

차량 이동은 입력 값에 따라 가속, 감속, 회전이 적용되는 방식으로 구성되어 있다.

키 입력 처리와 실제 물리 이동 로직이 분리되어 있어 흐름을 이해하기 수월하다.

속도 값은 단순 위치 이동이 아니라, 누적되는 형태로 관리된다.

이를 통해 가속과 감속의 차이가 체감되도록 설계되어 있다.

차량 회전은 현재 방향 벡터를 기준으로 처리되어 조작감에 영향을 준다.

이동 로직은 매 프레임 update 단계에서 갱신된다.

물리 엔진(Box2D)을 사용하는 경우, 직접 좌표 변경이 아닌 물리 연산을 통해 처리된다.

이러한 방식은 충돌 처리 및 트랙 경계 판정과의 연계를 쉽게 만든다.

차량 이동 로직을 이해하면서 전체 레이싱 흐름이 명확해졌다.

변경사항 3. 체크포인트 및 랩 카운트 시스템 이해

레이스 진행을 관리하는 체크포인트 및 랩 카운트 로직을 중심으로 구조를 정리하였다.

트랙 상의 체크포인트는 순차적으로 통과해야 하도록 설계되어 있다.

모든 체크포인트를 올바른 순서로 통과했을 때만 랩 완료로 인정된다.

시작/종료 라인은 별도의 기준 체크포인트로 처리되어 있다.

잘못된 순서로 체크포인트를 통과할 경우 랩이 증가하지 않도록 방어 로직이 존재한다.

랩 카운트는 현재 랩과 전체 랩 수를 함께 관리하여 진행 상황을 명확히 한다.

체크포인트 충돌 판정은 트리거 영역을 기준으로 처리된다.

이 방식은 차량 충돌과 구분되어 레이싱 흐름을 방해하지 않는다.

랩 완료 시점에 타이머 및 HUD 정보가 함께 갱신된다.

전체 레이스 진행 상태를 일관되게 관리하는 핵심 시스템임을 확인하였다.